from pymunk import Body, Vec2d
from engine.types import IBattery, IMotor


def non_zero(value: float) -> float:
    return value if value != 0 else 0.00001


class AcMotor(IMotor):
    # Assumed values
    KT = 0.1  # Torque constant - Nm/A (kT)
    KE = 0.1  # Back EMF constant - V/(rad/s) (kE)
    RESISTANCE = 0.1  # Resistance - Ohm (R)

    def __init__(
        self,
        meta,
        battery: IBattery,
        body: Body,
        wheel_position__cm: tuple[float, float],
        wheel_radius__m: float,
    ):
        super().__init__(meta, battery, body, wheel_position__cm, wheel_radius__m)
        self.wheel_speed__rad_s = 0.0
        self.back_emf__v = 0.0
        self.force__n = 0.0

    def request_force(self, force__n: float) -> None:
        """Requests a force (N) to be applied to the wheel.
        The force is applied at the wheel position during the postupdate phase.
        """
        self.force__n = force__n

    def preupdate(self):
        self._calc_wheel_speed()
        self._calc_back_emf()

    def postupdate(self):
        self._apply_force()

    def _apply_force(self):
        """Applies the force to the wheel based on the requested force.
        The force is applied at the wheel position.
        """
        torque__n_m = self._get_requested_torque()
        amps = self._calc_amps_from_desired_torque(t=torque__n_m)
        volts = self._calc_volts_to_achieve_amps(amps=amps)
        volts = self.battery.get_volts(volts=volts)
        got_power = self.battery.draw_power(volts=volts, amps=amps)

        if got_power:
            force = self.meta.convert_newton_to_pymunk(newton=self.force__n)
            self.body.apply_force_at_local_point(
                force=(force, 0), point=self.wheel_position__cm
            )

    def _calc_wheel_speed(self):
        """Calculates the wheel speed in rad/s based on the distance traveled by the wheel."""
        dist_vector: Vec2d = self.body.velocity_at_local_point(self.wheel_position__cm)
        angle__rad = self.body.angle
        # The distance traveled in the direction of the wheel
        dist_in_direction = dist_vector.dot(Vec2d(1, 0).rotated(angle__rad))
        dist_in_direction__m = self.meta.convert_pymunk_to_m(dist_in_direction)
        # Calculates the wheel speed in rad/timestep
        wheel_speed__rad_frame = non_zero(dist_in_direction__m) / self.wheel_radius__m
        # Convert to rad/s
        self.wheel_speed__rad_s = wheel_speed__rad_frame * self.meta.fps

    def _calc_back_emf(self):
        """Calculates the back EMF based on the wheel speed.
        The back EMF is the voltage (V) generated by the motor when it is spinning.
            E = kE * ω
        where:
            E = back EMF (V)
            kE = back EMF constant (V/(rad/s))
            ω = wheel speed (rad/s)
        """
        self.back_emf__v = self.KE * self.wheel_speed__rad_s

    def _get_requested_torque(self) -> float:
        """Gets the requested torque of the motor.
            T = F * r
        where:
            T = torque (Nm)
            F = force (N)
            r = wheel radius (m)
        """
        return self.force__n * self.wheel_radius__m

    def _calc_amps_from_desired_torque(self, t: float) -> float:
        """Calculates the required amps based on the desired torque.
        The amps are calculated using the torque constant (kT).
            T = kT * I   == solve I ==>   I = T / kT
        where:
            I = current (A)
            T = torque (Nm)
            kT = torque constant (Nm/A)
        """
        return non_zero(t) / self.KT

    def _calc_volts_to_achieve_amps(self, amps: float) -> float:
        """Calculates the required volts to achieve the desired amps.
        The volts are calculated using the resistance and back EMF.
            I = (V - E) / R   == solve V ==>   V = I * R + E
        where:
            V = voltage (V)
            I = current (A)
            R = resistance (Ohm)
            E = back EMF (V)
        """
        return amps * self.RESISTANCE + self.back_emf__v
