from typing import override
import pygame
from pymunk import Body, Vec2d
from engine.types import IBattery, IMotor
from sim_math.units import AngularSpeed, Distance, Force, Speed, Torque


def non_zero(value: float) -> float:
    return value if value != 0 else 0.00001


class AcMotor(IMotor):
    # Assumed values
    KT = 0.2  # Torque constant - Nm/A (kT)
    KE = 40  # Back EMF constant - V/krpm (kE)
    RESISTANCE = 0.1  # Resistance - Ohm (R)

    def __init__(
        self,
        meta,
        battery: IBattery,
        body: Body,
        max_torque: Torque,
        max_voltage: float,
        wheel_position: tuple[float, float],
        wheel_radius: Distance,
        unrestricted_force: bool = False,
        draw_debug: bool = False,
    ):
        super().__init__(
            meta=meta,
            battery=battery,
            body=body,
            wheel_position=wheel_position,
            wheel_radius=wheel_radius,
        )
        self.max_force = max_torque.to_force_at(radius=wheel_radius)
        self.max_voltage = max_voltage
        self._wheel_prev_pos = self.body.local_to_world(self.wheel_position)
        self._wheel_speed = AngularSpeed.in_base_unit(0.0)
        self._back_emf__v = 0.0
        self._force = Force.in_base_unit(0.0)
        self._unrestricted_force = unrestricted_force
        self._draw_debug = draw_debug

        self._ke__rad_s = AngularSpeed.in_rpm(AcMotor.KE * 1000).rad_s

        # Purely for visualization
        self._wheel_size = self.wheel_radius.base_unit
        self._wheel_pos_left = (
            self.wheel_position[0] * 0.9,
            self.wheel_position[1] * 0.9,
        )

    @override
    def request_force(self, force: Force) -> None:
        """Requests a force (N) to be applied to the wheel.
        The force is applied at the wheel position during the postupdate phase.
        """
        if not self._unrestricted_force:
            force = max(-self.max_force, min(self.max_force, force))
        self._force = force

    @override
    def request_force_scaled(self, force_scaler: float) -> None:
        """Requests a to be applied to the wheel from a value of -1 to 1.
        The force is applied at the wheel position during the postupdate phase.
        """
        self.request_force(force=self.max_force * force_scaler)

    @override
    def preupdate(self):
        self._calc_wheel_speed()
        self._calc_back_emf()

    @override
    def update(self):
        self._apply_force()

    @override
    def draw(self, surface):
        # Draw wheels as dots
        global_pos = self.body.local_to_world(self._wheel_pos_left)
        pygame.draw.circle(
            surface=surface,
            color=(0, 0, 0),
            center=self.meta.pymunk_to_pygame_point(global_pos, surface),
            radius=self.meta.pymunk_to_pygame_scale(self._wheel_size),
        )

    def _apply_force(self):
        """Applies the force to the wheel based on the requested force.
        The force is applied at the wheel position.
        """
        requested_torque = self._force.to_torque_at(radius=self.wheel_radius)
        amps = self._calc_amps_from_desired_torque(t=requested_torque)
        volts = self._calc_volts_to_achieve_amps(amps=amps)
        volts = min(volts, self.max_voltage)
        volts = self.battery.get_volts(volts=volts)
        got_power = self.battery.draw_power(volts=volts, amps=amps)

        # print(f"Requested torque: {requested_torque.nm:.2f} Nm, requested force: {self._force.n:.2f} N, Amps: {amps:.2f}, Volts: {volts:.2f}, Back EMF {self._back_emf__v:.2f}, Got power: {got_power:.2f}, remaining: {self.battery.remaining__wh:.2f} Wh")

        if got_power:
            # Forward force
            force = (self._force.base_unit, 0)
            self.body.apply_force_at_local_point(force=force, point=self.wheel_position)

    def _calc_wheel_speed(self):
        """Calculates the wheel speed in rad/s based on the distance traveled by the wheel."""
        current_pos = self.body.local_to_world(self.wheel_position)
        dist_vector = current_pos - self._wheel_prev_pos
        self._wheel_prev_pos = current_pos

        direction_vector = Vec2d(1, 0).rotated(self.body.angle)
        # The distance traveled in the direction of the wheel
        dist_in_direction = dist_vector.dot(direction_vector)

        # Calculates the wheel speed in rad/timestep
        self._wheel_speed = AngularSpeed.in_base_unit(
            non_zero(dist_in_direction) / self.wheel_radius.base_unit
        )

    def _calc_back_emf(self):
        """Calculates the back EMF based on the wheel speed.
        The back EMF is the voltage (V) generated by the motor when it is spinning.
            E = kE * ω
        where:
            E = back EMF (V)
            kE = back EMF constant (V/(rad/s))
            ω = wheel speed (rad/s)
        """
        self._back_emf__v = self._ke__rad_s * self._wheel_speed.rad_s

    def _calc_amps_from_desired_torque(self, t: Torque) -> float:
        """Calculates the required amps based on the desired torque.
        The amps are calculated using the torque constant (kT).
            T = kT * I   == solve I ==>   I = T / kT
        where:
            I = current (A)
            T = torque (Nm)
            kT = torque constant (Nm/A)
        """
        return non_zero(t.nm) / self.KT

    def _calc_volts_to_achieve_amps(self, amps: float) -> float:
        """Calculates the required volts to achieve the desired amps.
        The volts are calculated using the resistance and back EMF.
            I = (V - E) / R   == solve V ==>   V = I * R + E
        where:
            V = voltage (V)
            I = current (A)
            R = resistance (Ohm)
            E = back EMF (V)
        """
        return amps * self.RESISTANCE + self._back_emf__v
